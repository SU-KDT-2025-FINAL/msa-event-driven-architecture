# MSA 구축 단계 및 실무 적용 가이드

## 1. 서비스 분리
- **고려 요소**: 도메인 주도 설계(DDD), 비즈니스 기능별 경계, 팀 조직 구조
- **기술 스택**: Spring Boot, Node.js, Python Flask 등(서비스별 독립적 선택 가능)
- **실무 팁**: 서비스 간 결합도를 최소화하고, API 명세(예: OpenAPI/Swagger)로 인터페이스를 명확히 정의

## 2. 데이터 분리
- **고려 요소**: 각 서비스별 독립 데이터베이스, 데이터 일관성, 트랜잭션 처리 방식
- **기술 스택**: MySQL, PostgreSQL, MongoDB 등(서비스별로 최적화된 DB 선택)
- **실무 팁**: 서비스 간 데이터 공유는 API 또는 이벤트(예: Kafka)로 처리, DB 스키마 공유 금지

## 3. 통신 방식 선택
- **고려 요소**: 동기/비동기 통신, API 게이트웨이, 메시지 브로커 도입 여부
- **기술 스택**: REST API(Spring Web), gRPC, Apache Kafka, RabbitMQ, API Gateway(Kong, NGINX 등)
- **실무 팁**: 서비스 간 실시간성이 중요하면 REST/gRPC, 비동기 이벤트 기반이면 Kafka/RabbitMQ 활용

## 4. 인증/인가
- **고려 요소**: 중앙 인증 vs 서비스별 인증, OAuth2/JWT, SSO, 권한 관리
- **기술 스택**: Spring Security, OAuth2, JWT, Keycloak, Auth0
- **실무 팁**: 인증은 중앙 집중(SSO), 인가는 서비스별 세분화 권장. 토큰 기반 인증(JWT) 활용

## 5. 배포/모니터링
- **고려 요소**: CI/CD 파이프라인, 무중단 배포, 서비스 헬스체크, 로깅/모니터링
- **기술 스택**: Docker, Kubernetes, Jenkins/GitHub Actions, Prometheus, Grafana, ELK(Elasticsearch, Logstash, Kibana)
- **실무 팁**: 각 서비스는 독립적으로 배포, 모니터링/로깅은 중앙 집중화

---

# 마이크로서비스 환경에서의 Git 리포지토리 구성 전략

## 1. Monorepo
- **특징**: 여러 마이크로서비스를 하나의 리포지토리에서 관리
- **장점**: 코드 공유/리팩토링 용이, 일관된 빌드/테스트 환경, 변경 이력 추적 쉬움
- **단점**: 리포지토리 커짐, 권한 관리 어려움, 빌드 시간 증가 가능
- **적합 사례**: 소규모 팀, 서비스 간 강한 연관성, 통합 배포가 필요한 경우

## 2. Multi-repo
- **특징**: 서비스별로 독립 리포지토리 운영
- **장점**: 서비스별 독립성 극대화, 권한/배포/릴리즈 관리 용이, 팀별 자율성
- **단점**: 코드 중복 가능성, 공통 모듈 관리 어려움, 변경 이력 분산
- **적합 사례**: 대규모 조직, 서비스별 독립 개발/배포, 팀별 책임 명확화

## 3. 실무 선택 기준
- **조직 규모**: 소규모(모노레포), 대규모(멀티레포)
- **서비스 독립성**: 높을수록 멀티레포 선호
- **공통 코드/라이브러리 관리**: 빈번하면 모노레포, 드물면 멀티레포
- **CI/CD 및 권한 관리**: 복잡성에 따라 선택

> **실무에서는 대규모 조직, 서비스 독립 배포가 중요한 경우 Multi-repo를, 소규모 팀이나 통합 관리가 필요한 경우 Monorepo를 주로 선택합니다. 최근에는 Hybrid(공통 라이브러리만 모노레포, 서비스는 멀티레포) 전략도 활용됩니다. 