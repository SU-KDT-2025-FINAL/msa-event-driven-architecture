# 1-1. 이벤트 기반 아키텍처 기초

## 개요

이벤트 기반 아키텍처(EDA)는 전통적인 요청-응답 패턴에서 반응형, 느슨하게 결합된 시스템 설계로의 패러다임 전환을 나타냅니다. 이 문서는 이벤트 기반 시스템의 이론적 기초와 실제적 의미를 탐구합니다.

## 이벤트 의미론과 특성

### 이벤트 정의

**이벤트**는 시스템에서 특정 시점에 발생한 불변의 사실을 나타냅니다. 이벤트는 "무언가를 하라"가 아닌 "무언가가 일어났다"는 의미를 가지므로, 명령(command)과는 근본적으로 다릅니다.

### 핵심 이벤트 속성

**불변성**: 생성된 후에는 이벤트를 수정할 수 없습니다. 이러한 불변성은 시스템에서 일어난 일의 역사적 기록이 그대로 유지되도록 보장하고 신뢰할 수 있는 감사 추적을 제공합니다.

**시간적 순서**: 이벤트는 명시적인 타임스탬프를 가지며 인과 관계를 유지합니다. 이러한 시간적 측면은 분산 시스템에서 일관성을 유지하고 이벤트 재생 시나리오를 가능하게 하는 데 중요합니다.

**자기 완결성**: 이벤트는 소비자가 추가적인 서비스 호출이나 데이터베이스 조회 없이 독립적으로 처리할 수 있도록 충분한 컨텍스트를 포함해야 합니다.

**비즈니스 의미론**: 이벤트는 비즈니스 이해관계자들이 이해할 수 있고 도메인 모델과 연관시킬 수 있는 도메인적으로 의미 있는 발생 사건을 나타냅니다.

## 이벤트 분류

### 도메인 이벤트

도메인 전문가들이 관심을 갖는 비즈니스적으로 중요한 발생 사건입니다. 이러한 이벤트는 비즈니스 엔티티와 워크플로우의 상태 변화를 나타냅니다.

```json
{
  "eventType": "OrderPlaced",
  "aggregateId": "order-12345",
  "timestamp": "2024-07-24T10:30:00Z",
  "version": 1,
  "causationId": "command-67890",
  "correlationId": "process-abc123",
  "payload": {
    "customerId": "customer-789",
    "items": [
      {
        "productId": "product-456",
        "quantity": 2,
        "unitPrice": 149.99
      }
    ],
    "totalAmount": 299.99,
    "shippingAddress": {
      "street": "123 Main St",
      "city": "Springfield",
      "zipCode": "12345"
    }
  },
  "metadata": {
    "userId": "user-321",
    "sessionId": "session-654",
    "source": "web-app"
  }
}
```

### 시스템 이벤트

시스템 운영, 인프라스트럭처, 서비스 생명주기 관리와 관련된 기술적 발생 사건입니다.

```json
{
  "eventType": "ServiceStarted",
  "serviceId": "payment-service-instance-3",
  "timestamp": "2024-07-24T10:00:00Z",
  "metadata": {
    "version": "2.1.4",
    "environment": "production",
    "nodeId": "node-prod-03",
    "configuration": {
      "maxConnections": 1000,
      "timeoutMs": 30000
    }
  }
}
```

## 이벤트 기반 통신 패턴

### Fire-and-Forget

발행자가 승인을 기대하지 않고 이벤트를 방출합니다. 이 패턴은 결합도를 최대화하지만 오류 처리와 모니터링에 대한 신중한 고려가 필요합니다.

**사용 사례**:
- 감사 로깅
- 분석 데이터 수집
- 비중요 알림

**고려사항**:
- 전달 보장 없음
- 응답이 아닌 메트릭을 통한 모니터링
- 소비자의 멱등성 요구사항

### 이벤트를 통한 요청-응답

상관관계 ID를 사용하여 요청과 응답을 매칭하는 비동기 요청-응답입니다. 이 패턴은 비동기 처리의 이점을 유지하면서 응답 의미론을 제공합니다.

```java
// 요청
public class PaymentProcessingRequested {
    private String correlationId;
    private String orderId;
    private BigDecimal amount;
    // ... 기타 필드
}

// 응답
public class PaymentProcessingCompleted {
    private String correlationId; // 요청과 매칭
    private String paymentId;
    private PaymentStatus status;
    // ... 기타 필드
}
```

### 이벤트 협업

여러 서비스가 이벤트 발행과 구독을 통해 비즈니스 프로세스를 협업적으로 처리합니다. 각 서비스는 자체 상태를 유지하고 관련 이벤트에 반응합니다.

### 이벤트 알림

서비스 동기화를 트리거하는 가벼운 알림입니다. 알림은 최소한의 데이터를 포함하며, 소비자는 필요시 추가 세부사항을 가져옵니다.

## 이벤트 순서와 인과관계

### 인과적 일관성

이벤트는 상관관계와 원인 식별자를 통해 인과관계를 유지합니다. 이는 분산 환경에서도 적절한 이벤트 순서를 가능하게 합니다.

**벡터 클럭**: 분산 시스템에서 이벤트 간의 인과관계를 포착하는 논리적 타임스탬프입니다.

**Happens-Before 관계**: 실제 시간이 아닌 인과적 의존성을 기반으로 한 이벤트의 부분적 순서입니다.

### 파티션 순서

**파티션 내 순서**: 동일한 파티션 내의 이벤트는 엄격한 순서를 유지하며, 일반적으로 이벤트 브로커에 의해 보장됩니다.

**파티션 간 순서**: 파티션 간에는 전역적 순서 보장이 없으므로, 파티션 키와 이벤트 상관관계의 신중한 설계가 필요합니다.

## 모범 사례

### 이벤트 설계

- 비즈니스 의도를 반영하는 명확하고 설명적인 이벤트 이름 사용
- 소비자 의존성을 피하기 위해 이벤트에 충분한 컨텍스트 포함
- 안정성과 지속성을 위한 이벤트 설계
- 이벤트 데이터의 프라이버시와 보안 의미 고려

### 오류 처리

- 독성 메시지를 위한 데드 레터 큐 구현
- 비즈니스 프로세스 실패를 위한 보상 메커니즘 설계
- 연쇄 실패를 방지하기 위한 회로 차단기 사용
- 이벤트 처리 실패에 대한 모니터링과 알림

### 성능 최적화

- 부하 분산을 위한 적절한 파티션 키 선택
- 고처리량 시나리오를 위한 배칭 구현
- 대용량 이벤트를 위한 압축 사용
- 효율적인 직렬화 형식 설계