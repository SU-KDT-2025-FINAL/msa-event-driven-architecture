# Meeting Place (미팅 플레이스) - MSA 이벤트 드리븐 아키텍처

## 1. 프로젝트 개요

### 프로젝트명
**Meeting Place (미팅 플레이스)** - 공평하고 재미있는 약속 장소 추천 서비스

### 서비스 존재 이유 (Value Proposition)
- **공평성**: 두 사용자의 중간지점을 기반으로 한 공정한 장소 추천
- **타당성**: 약속 종류(술약속, 영화약속 등)에 맞는 최적화된 장소 추천
- **신속성**: AI 기반 빠른 장소 검색 및 추천
- **재미요소**: 미니게임을 통한 승리자 우선권 부여로 약속 장소 결정 과정의 재미 증대
- **타겟 사용자**: 10~30대 젊은 세대 (게임 요소와 빠른 의사결정을 선호하는 그룹)

### 핵심 기능
- **위치 입력**: 두 사용자의 위치 정보 수집
- **중간지점 계산**: 두 위치의 정확한 중간지점 도출(지오코딩) 좌표를 통한 계산
-> 지오코딩은 정확한 주소지 입력시 해당 주소지의 경도 위도 와같은 좌표 값을 받을 수 있는 API
-> 월 무료 호출 횟수가 정해져 있기 때문에 사용자의 정확한 위치가 아닌 00시 00도 00동구 단위까지에 해당하는 좌표값을 db에 저장해서 추후 사용자입력시 중간지점 계산에 활용
-> 정확한 주소지 (도로명까지) 입력하는 이유는 사용자의 정확한 위치에서 중간 지점까지 가는 방법, 가는 시간 등 정보를 제공하기 위함. 사용자 위치 입력시 입력 포맷 형식을 정하고 해당 포맷에서 00동 까지만 저장할 생각
- **약속 종류별 추천**: 술약속(번화가), 영화약속(영화관) 등 카테고리별 장소 추천
-> perplexity api(pro)를 통해 추천 로직 구현 및 후처리를 통한 응답 포맷 고정
- **미니게임 시스템**: 승리자가 유리한 위치에서 약속 장소 결정
-> 이 기능은 사용자와 사용자의 실시간 문제 정답에 따라 변화하는 UI를 제공하면 좋을 것 같음 image copy.png 참고 
- **실시간 추천**: 위치 기반 실시간 장소 추천
-> 사용자의 구체적인 요구사항에 대해 고려하여 장소 추천 가능
- **게임 기반 위치 조정**: 퀴즈 승리 시 본인 위치에 더 가까운 장소 우선 추천
-> 승리자 마음대로 장소를 정할 수도 있고 퀴즈를 맞출 때마다 거리 비율을 유리하게 가져갈 수 있음(추후 생각)

## 2. 프로젝트 구조 및 배포 전략

### 2.1 MSA 프로젝트 구조 (트리 형식)
```
meeting-place/
├── frontend/
│   ├── meeting-place-web/          # React 웹 애플리케이션
│   └── meeting-place-mobile/       # React Native 모바일 앱
├── backend/
│   ├── user-service/               # 사용자 관리 서비스
│   ├── location-service/           # 위치 계산 서비스
│   ├── place-service/              # 장소 추천 서비스
│   ├── game-service/               # 미니게임 서비스
│   ├── meeting-service/            # 약속 관리 서비스
│   └── notification-service/       # 알림 서비스
├── infrastructure/
│   ├── terraform/                  # AWS 인프라 코드 (Terraform)
│   │   ├── rds.tf                  # RDS MySQL 설정
│   │   ├── vpc.tf                  # VPC, 서브넷 설정
│   │   ├── eks.tf                  # EKS 클러스터 설정
│   │   ├── redis.tf                # ElastiCache Redis 설정
│   │   └── variables.tf            # 변수 정의
│   ├── kafka/                      # Kafka 설정 (MSK 또는 EKS)
│   └── elasticsearch/              # Elasticsearch 설정 (OpenSearch)
├── k8s/                            # Kubernetes 매니페스트
├── argocd/                         # ArgoCD 설정
├── github-actions/                 # CI/CD 파이프라인
├── docker-compose.yml              # 로컬 개발 환경
└── README.md
```

### 2.2 배포 전략
- **Development**: GitHub Actions → ECR → ArgoCD → EKS Dev Cluster
- **Staging**: GitHub Actions → ECR → ArgoCD → EKS Staging Cluster  
- **Production**: GitHub Actions → ECR → ArgoCD → EKS Production Cluster

### 2.3 AWS 인프라 구성 (Terraform으로 관리)
- **RDS**: MySQL (Multi-AZ, Read Replicas)
- **ElastiCache**: Redis Cluster
- **MSK**: Apache Kafka (또는 EKS에서 Kafka)
- **OpenSearch**: Elasticsearch 호환 검색 엔진
-> 내 데이터 베이스 내부에서 장소, 사용자별, 선호도와 같은 부분들 검색 엔진(사용 안해도 될 수도)
- **EKS**: Kubernetes 클러스터
- **VPC**: 프라이빗/퍼블릭 서브넷 분리
- **ALB**: Application Load Balancer

### 2.4 Infrastructure as Code (IaC)
```hcl
# infrastructure/terraform/rds.tf 예시
resource "aws_db_instance" "meeting_place_db" {
  identifier = "meeting-place-${var.environment}"
  engine = "mysql"
  engine_version = "8.0"
  instance_class = var.db_instance_class
  allocated_storage = 20
  storage_type = "gp3"
  
  db_name = "meeting_place"
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name = aws_db_subnet_group.main.name
  
  backup_retention_period = 7
  backup_window = "03:00-04:00"
  maintenance_window = "sun:04:00-sun:05:00"
  
  multi_az = var.environment == "production"
  
  tags = {
    Environment = var.environment
    Project = "meeting-place"
  }
}
```

### 2.5 컨테이너화 전략
```dockerfile
# Spring Boot 서비스 Dockerfile
FROM maven:3.8.4-openjdk-17 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

FROM openjdk:17-jre-slim
WORKDIR /app
COPY --from=build /app/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

## 3. 마이크로서비스 분해 (Service Decomposition)

### 3.1 사용자 관리 서비스 (User Management Service)
- **책임**: 사용자 프로필, 소셜 로그인, 친구 관리, 위치 정보, 약속 히스토리 관리
- **기술 스택**: Spring Boot, MySQL, Redis, OAuth 2.0
- **주요 기능**:
  - 소셜 로그인 (Google, Kakao, Naver)
  - 사용자 등록/수정/삭제
  - 친구 추가/삭제
  - 친구 리스트 관리
  - 위치 정보 업데이트
  - 약속 참여 이력 관리
  - 사용자 선호도 설정
  - 친구 초대 링크 생성(초대 링크를 통한 회원가입 시 자동으로 링크를 보낸 사용자와 친구가 될 수 있도록)
  - 서비스 이용횟수, 미니게임 승리 횟수에 따른 칭호, 등급 관리(없어도 됨)

### 3.2 위치 계산 서비스 (Location Calculation Service)
- **책임**: 중간지점 계산, 거리 계산, 지오코딩
- **기술 스택**: Spring Boot, Redis, Google Maps API (또는 대안)
- **주요 기능**:
  - 두 지점 간 중간지점 계산 (백엔드 로직)
  - 실시간 거리 계산 (백엔드 로직)
  - 주소 ↔ 좌표 변환 (지오코딩/리버스 지오코딩)
에는   - 교통수단별 예상 시간 계산 (Kakao Maps API 추천 - 월 30만회 무료)

### 3.3 장소 추천 서비스 (Place Recommendation Service)
- **책임**: 카테고리별 장소 검색 및 추천
- **기술 스택**: Spring Boot, Elasticsearch, Redis, Perplexity API
- **주요 기능**:
  - 카테고리별 장소 검색 (술집, 영화관, 카페 등)
  - 거리 기반 필터링
  - 평점 및 리뷰 기반 추천
  - 실시간 영업 상태 확인

### 3.4 미니게임 서비스 (Mini Game Service)
- **책임**: 게임 진행, 결과 처리, 보상 시스템, 실시간 멀티플레이어
- **기술 스택**: Spring Boot, WebSocket, Redis, MySQL
- **주요 기능**:
  - 실시간 멀티플레이어 게임 진행
  - 게임 방 생성 및 관리
  - 게임 결과 저장
  - 승리자 보상 (위치 우선권)
  - 게임 통계 및 랭킹
  - 친구 간 게임 매칭
  - 게임 초대 및 참여

### 3.5 약속 관리 서비스 (Meeting Management Service)
- **책임**: 약속 생성, 상태 관리, 참여자 관리
- **기술 스택**: Spring Boot, MySQL, Redis
- **주요 기능**:
  - 약속 생성 및 수정
  - 참여자 초대 및 수락/거절
  - 약속 상태 관리 (대기/확정/완료)
  - 약속 히스토리 관리

### 3.6 알림 서비스 (Notification Service)
- **책임**: 실시간 알림, 푸시 메시지, 이메일
- **기술 스택**: Spring Boot, WebSocket, 네이버 SENS: 월 1,000건 무료
-> AWS SNS 월 1,000건(미국 번호), 한국 번호는 유료 건당 8.5원
- **주요 기능**:
  - 실시간 약속 알림
  - 게임 시작/종료 알림
  - 위치 업데이트 알림
  - 약속 리마인더

## 4. 이벤트 드리븐 아키텍처 설계

### 4.1 핵심 도메인 이벤트

#### 사용자 관련 이벤트
```json
// UserLocationUpdatedEvent
{
  "eventId": "uuid",
  "eventType": "UserLocationUpdated",
  "userId": "user123",
  "latitude": 37.5665,
  "longitude": 126.9780,
  "timestamp": "2024-01-15T10:30:00Z",
  "locationName": "강남역"
}

// UserPreferenceUpdatedEvent
{
  "eventId": "uuid",
  "eventType": "UserPreferenceUpdated",
  "userId": "user123",
  "preferences": {
    "favoriteCategories": ["술집", "카페"],
    "maxDistance": 5000,
    "budgetRange": "medium"
  }
}
```

#### 약속 관련 이벤트
```json
// MeetingCreatedEvent
{
  "eventId": "uuid",
  "eventType": "MeetingCreated",
  "meetingId": "meeting456",
  "creatorId": "user123",
  "participants": ["user123", "user456"],
  "category": "술약속",
  "status": "PENDING",
  "createdAt": "2024-01-15T10:30:00Z"
}

// LocationCalculatedEvent
{
  "eventId": "uuid",
  "eventType": "LocationCalculated",
  "meetingId": "meeting456",
  "midpoint": {
    "latitude": 37.5665,
    "longitude": 126.9780
  },
  "participantLocations": [
    {"userId": "user123", "location": {...}},
    {"userId": "user456", "location": {...}}
  ]
}

// PlaceRecommendedEvent
{
  "eventId": "uuid",
  "eventType": "PlaceRecommended",
  "meetingId": "meeting456",
  "recommendedPlaces": [
    {
      "placeId": "place789",
      "name": "강남 술집",
      "category": "술집",
      "distance": 500,
      "rating": 4.5,
      "location": {...}
    }
  ]
}
```

#### 게임 관련 이벤트
```json
// GameStartedEvent
{
  "eventId": "uuid",
  "eventType": "GameStarted",
  "meetingId": "meeting456",
  "gameId": "game789",
  "gameType": "QUIZ",
  "participants": ["user123", "user456"],
  "startTime": "2024-01-15T10:30:00Z"
}

// GameCompletedEvent
{
  "eventId": "uuid",
  "eventType": "GameCompleted",
  "gameId": "game789",
  "winnerId": "user123",
  "winnerLocation": {...},
  "loserId": "user456",
  "loserLocation": {...},
  "gameResult": {
    "score": {"user123": 100, "user456": 80},
    "duration": 300
  }
}
```

### 3.2 이벤트 스토어 설계

#### Apache Kafka 토픽 구조
```
# 사용자 관련 토픽
user-events
├── user.created
├── user.location.updated
├── user.preference.updated
└── user.deleted

# 약속 관련 토픽
meeting-events
├── meeting.created
├── meeting.location.calculated
├── meeting.place.recommended
├── meeting.confirmed
└── meeting.completed

# 게임 관련 토픽
game-events
├── game.started
├── game.round.completed
├── game.completed
└── game.reward.granted

# 장소 관련 토픽
place-events
├── place.updated
├── place.rating.changed
└── place.status.changed
```

#### 이벤트 스키마 관리 (Schema Registry)
```json
// 이벤트 스키마 예시
{
  "schema": {
    "type": "object",
    "properties": {
      "eventId": {"type": "string", "format": "uuid"},
      "eventType": {"type": "string"},
      "timestamp": {"type": "string", "format": "date-time"},
      "version": {"type": "string"},
      "data": {"type": "object"}
    },
    "required": ["eventId", "eventType", "timestamp", "version"]
  }
}
```

## 5. 데이터 모델 및 저장소

### 5.1 필요한 데이터 종류

#### 사용자 데이터
- **프로필 정보**: 이름, 이메일, 전화번호, 프로필 이미지
- **위치 정보**: 현재 위치, 자주 방문하는 장소, 선호 지역
- **선호도**: 좋아하는 장소 카테고리, 예산 범위, 거리 제한
- **게임 통계**: 승률, 총 게임 수, 획득 포인트

#### 장소 데이터
- **기본 정보**: 이름, 주소, 좌표, 카테고리, 연락처
- **영업 정보**: 영업시간, 휴무일, 예약 가능 여부
- **평가 정보**: 평점, 리뷰 수, 방문자 수
- **실시간 정보**: 현재 혼잡도, 대기 시간, 특별 이벤트

#### 약속 데이터
- **약속 정보**: 제목, 설명, 카테고리, 날짜/시간
- **참여자 정보**: 참여자 목록, 역할, 응답 상태
- **위치 정보**: 중간지점, 추천 장소, 최종 선택 장소
- **게임 정보**: 게임 결과, 승리자, 보상 내용

### 5.2 데이터베이스 선택 전략

#### MySQL (주 데이터베이스)
- **용도**: 사용자, 약속, 게임 결과 등 관계형 데이터
- **특징**: ACID 트랜잭션, 복잡한 쿼리 지원
- **테이블**: users, meetings, games, game_results

#### Redis (캐시 및 세션)
- **용도**: 실시간 데이터, 세션 관리, 게임 상태
- **특징**: 빠른 읽기/쓰기, 데이터 구조 다양성
- **데이터**: 사용자 세션, 게임 상태, 실시간 위치

#### Elasticsearch (검색 엔진)
- **용도**: 장소 검색, 사용자 검색, 로그 분석
- **특징**: 전문 검색, 집계 쿼리, 실시간 분석
- **인덱스**: places, users, meeting_logs

#### MongoDB (문서 저장소)
- **용도**: 게임 로그, 사용자 활동 히스토리
- **특징**: 유연한 스키마, 대용량 데이터 처리
- **컬렉션**: game_logs, user_activities, meeting_analytics

## 6. 이벤트 소싱 활용 아이디어

### 6.1 시간 여행 기능
```json
// 특정 시점의 약속 상태 복원
{
  "meetingId": "meeting456",
  "timestamp": "2024-01-15T10:30:00Z",
  "state": {
    "participants": ["user123", "user456"],
    "midpoint": {...},
    "recommendedPlaces": [...],
    "gameStatus": "IN_PROGRESS"
  }
}
```

### 6.2 감사 추적 및 분석
- **사용자 행동 분석**: 위치 변경 패턴, 선호도 변화
- **게임 통계**: 승률 변화, 게임 유형별 성과
- **장소 인기도**: 추천 횟수, 실제 방문률
- **시스템 성능**: 응답 시간, 오류율 추적

### 6.3 A/B 테스팅
```json
// 추천 알고리즘 비교 실험
{
  "experimentId": "exp123",
  "algorithmA": "distance_based",
  "algorithmB": "rating_distance_hybrid",
  "results": {
    "userSatisfaction": {"A": 0.75, "B": 0.82},
    "conversionRate": {"A": 0.60, "B": 0.68}
  }
}
```

### 6.4 예측 분석
- **사용자 행동 예측**: 다음 방문 장소, 선호도 변화
- **장소 인기도 예측**: 계절별, 시간대별 방문자 수
- **게임 결과 예측**: 사용자별 승률 예측
- **시스템 부하 예측**: 피크 시간대 예측

## 7. 실시간 기능 구현

### 7.1 WebSocket을 통한 실시간 통신
```javascript
// 클라이언트 측 WebSocket 연결
const socket = new WebSocket('ws://api.meeting-app.com/ws');

// 실시간 위치 업데이트
socket.send(JSON.stringify({
  type: 'LOCATION_UPDATE',
  userId: 'user123',
  location: {lat: 37.5665, lng: 126.9780}
}));

// 실시간 게임 진행
socket.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.type === 'GAME_UPDATE') {
    updateGameUI(data.gameState);
  }
};
```

### 7.2 실시간 추천 시스템
```java
// 실시간 추천 서비스
@Service
public class RealTimeRecommendationService {
    
    @EventListener
    public void handleLocationUpdate(UserLocationUpdatedEvent event) {
        // 실시간으로 주변 장소 추천 업데이트
        List<Place> nearbyPlaces = placeService.findNearbyPlaces(
            event.getLatitude(), 
            event.getLongitude(), 
            1000 // 1km 반경
        );
        
        // 추천 점수 계산 및 정렬
        List<PlaceRecommendation> recommendations = 
            calculateRecommendations(nearbyPlaces, event.getUserId());
        
        // 실시간 알림 발송
        notificationService.sendRecommendation(event.getUserId(), recommendations);
    }
}
```

## 8. 소셜 로그인 및 친구 시스템 설계

### 8.1 카카오 API 친구 목록 연동

#### **카카오 친구 목록 접근 가능 여부**
```java
// 카카오 API를 통한 친구 목록 조회 (제한적)
@Service
public class KakaoFriendService {
    
    /*
     * ✅ 가능한 기능:
     * 1. 카카오 친구 목록 조회 (최대 20명)
     * 2. 앱에 가입한 친구만 필터링
     * 3. 카카오톡으로 앱 초대 메시지 발송
     * 4. 친구의 기본 정보 (닉네임, 프로필 이미지)
     * 
     * ❌ 제한사항:
     * 1. 앱에 가입하지 않은 친구는 조회 불가
     * 2. 친구의 상세 정보 (전화번호, 이메일 등) 접근 불가
     * 3. 하루 최대 50건 초대 메시지 발송 제한
     * 4. 사용자가 friends, talk_message 권한 동의 필요
     */
    
    // 카카오 친구 목록 조회 (전제조건: friends 권한 필요)
    public List<KakaoFriend> getKakaoFriends(String accessToken) {
        // 1. 권한 확인
        if (!hasFriendsPermission(accessToken)) {
            throw new KakaoPermissionException("friends 권한이 필요합니다.");
        }
        
        // 2. 카카오 API 호출
        KakaoFriendsResponse response = kakaoApiClient.getFriends(accessToken);
        
        // 3. 앱에 가입한 친구만 필터링 (최대 20명)
        return response.getFriends().stream()
                .filter(friend -> friend.isAppRegistered())
                .limit(20)
                .map(this::convertToKakaoFriend)
                .collect(Collectors.toList());
    }
    
    // friends 권한 확인
    private boolean hasFriendsPermission(String accessToken) {
        try {
            KakaoScopeResponse scopeResponse = kakaoApiClient.getScopes(accessToken);
            return scopeResponse.getScopes().contains("friends");
        } catch (Exception e) {
            return false;
        }
    }
    
    // 카카오 친구에게 앱 초대 메시지 발송
    public void inviteKakaoFriends(String accessToken, List<String> friendIds) {
        for (String friendId : friendIds) {
            try {
                kakaoApiClient.sendInvitation(accessToken, friendId);
                // 초대 발송 기록 저장
                saveInvitationRecord(friendId, InvitationType.KAKAO);
            } catch (Exception e) {
                log.error("카카오 친구 초대 실패: {}", e.getMessage());
            }
        }
    }
}

// 카카오 API 클라이언트
@Component
public class KakaoApiClient {
    
    // 카카오 친구 목록 조회 API (전제조건: friends 권한)
    public KakaoFriendsResponse getFriends(String accessToken) {
        String url = "https://kapi.kakao.com/v1/api/talk/friends";
        
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(accessToken);
        
        ResponseEntity<KakaoFriendsResponse> response = restTemplate.exchange(
                url, HttpMethod.GET, new HttpEntity<>(headers), KakaoFriendsResponse.class);
        
        return response.getBody();
    }
    
    // 카카오 권한 스코프 조회 API
    public KakaoScopeResponse getScopes(String accessToken) {
        String url = "https://kapi.kakao.com/v1/user/access_token_info";
        
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(accessToken);
        
        ResponseEntity<KakaoScopeResponse> response = restTemplate.exchange(
                url, HttpMethod.GET, new HttpEntity<>(headers), KakaoScopeResponse.class);
        
        return response.getBody();
    }
    
    // 카카오톡 초대 메시지 발송
    public void sendInvitation(String accessToken, String friendId) {
        String url = "https://kapi.kakao.com/v1/api/talk/friends/message/default/send";
        
        KakaoInvitationRequest request = KakaoInvitationRequest.builder()
                .receiverUuids(Arrays.asList(friendId))
                .templateObject(KakaoTemplateObject.builder()
                        .objectType("feed")
                        .content(KakaoContent.builder()
                                .title("Meeting Place 초대")
                                .description("함께 약속 장소를 정해보세요!")
                                .imageUrl("https://meeting-app.com/invite-image.jpg")
                                .link(KakaoLink.builder()
                                        .webUrl("https://meeting-app.com/invite")
                                        .mobileWebUrl("https://meeting-app.com/invite")
                                        .build())
                                .build())
                        .build())
                .build();
        
        HttpHeaders headers = new HttpHeaders();
        headers.setBearerAuth(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        restTemplate.postForEntity(url, new HttpEntity<>(request, headers), String.class);
    }
}
```

#### **하이브리드 친구 시스템 설계**
```java
// 카카오 친구 + 앱 내 친구 통합 관리
@Service
public class HybridFriendService {
    
    // 1. 카카오 친구에서 앱 친구 자동 추가 제안
    public List<FriendSuggestion> getKakaoFriendSuggestions(String userId) {
        String accessToken = getKakaoAccessToken(userId);
        List<KakaoFriend> kakaoFriends = kakaoFriendService.getKakaoFriends(accessToken);
        
        return kakaoFriends.stream()
                .map(kakaoFriend -> FriendSuggestion.builder()
                        .suggestionType(SuggestionType.KAKAO_FRIEND)
                        .userId(kakaoFriend.getUserId())
                        .nickname(kakaoFriend.getNickname())
                        .profileImage(kakaoFriend.getProfileImage())
                        .isAlreadyFriend(isAlreadyFriend(userId, kakaoFriend.getUserId()))
                        .build())
                .filter(suggestion -> !suggestion.isAlreadyFriend())
                .collect(Collectors.toList());
    }
    
    // 2. 수동 친구 검색 (닉네임, 이메일, 전화번호)
    public List<UserProfile> searchFriends(String keyword) {
        return userRepository.findByNicknameContainingOrEmailContaining(keyword, keyword);
    }
    
    // 3. 친구 추가 (카카오 친구 자동 추가)
    public void addKakaoFriend(String userId, String kakaoFriendId) {
        // 카카오 친구를 앱 친구로 자동 추가
        createFriendship(userId, kakaoFriendId);
    }
    
    // 5. 카카오 친구에게 앱 초대 메시지 발송
    public void inviteKakaoFriendsToApp(String userId, List<String> kakaoFriendIds) {
        String accessToken = getKakaoAccessToken(userId);
        
        for (String friendId : kakaoFriendIds) {
            try {
                kakaoApiClient.sendInvitation(accessToken, friendId);
                // 초대 발송 기록 저장
                saveInvitationRecord(userId, friendId, InvitationType.KAKAO);
            } catch (Exception e) {
                // 초대 실패 로그 기록
                logInvitationFailure(userId, friendId, e.getMessage());
            }
        }
    }
}
```

#### **카카오 API 권한 설정 (전제조건)**
```yaml
# application.yml - 카카오 API 설정
kakao:
  client-id: ${KAKAO_CLIENT_ID}
  client-secret: ${KAKAO_CLIENT_SECRET}
  redirect-uri: https://meeting-app.com/auth/kakao/callback
  scope:
    - profile_nickname
    - profile_image
    - friends          # 카카오 친구 목록 조회 권한 (필수!)
    - talk_message     # 카카오톡 메시지 발송 권한 (필수!)

# 카카오 개발자 콘솔에서 설정해야 할 사항:
# 1. 앱 등록 및 Client ID, Client Secret 발급
# 2. Redirect URI 설정
# 3. 동의항목 설정에서 "카카오 친구 목록" 권한 활성화
# 4. 동의항목 설정에서 "카카오톡 메시지 전송" 권한 활성화
```

#### **카카오 친구 시스템 전제조건 및 제약사항**
```java
// 카카오 친구 목록 접근 전제조건 및 제약사항
@Service
public class KakaoFriendLimitationService {
    
    /*
     * 🚨 전제조건 (반드시 충족해야 함):
     * 
     * 1. 카카오 개발자 콘솔 설정
     *    - 앱 등록 및 Client ID, Client Secret 발급
     *    - Redirect URI 설정
     *    - 동의항목에서 "카카오 친구 목록" 권한 활성화
     *    - 동의항목에서 "카카오톡 메시지 전송" 권한 활성화
     * 
     * 2. 사용자 동의 필수
     *    - friends: 카카오 친구 목록 조회 권한
     *    - talk_message: 카카오톡 메시지 발송 권한
     * 
     * 3. 앱 심사 승인
     *    - 카카오에서 앱 심사 후 승인 필요
     *    - 친구 목록 접근 권한은 심사가 까다로움
     * 
     * 📋 제약사항:
     * 
     * 1. 친구 목록 제한
     *    - 앱에 가입한 친구만 조회 가능
     *    - 최대 20명까지만 조회 가능
     *    - 친구의 프로필 정보는 제한적 (닉네임, 프로필 이미지)
     * 
     * 2. 초대 메시지 제한
     *    - 하루 최대 50건 발송 제한
     *    - 스팸 방지를 위한 제한
     * 
     * 3. 대안 전략 (권한이 없거나 제한된 경우)
     *    - 수동 친구 검색 기능
     *    - 초대 링크 공유 기능
     *    - QR 코드를 통한 친구 추가
     *    - 전화번호 기반 친구 찾기
     */
    
    public boolean canAccessKakaoFriends(String accessToken) {
        KakaoScopeResponse scopeResponse = kakaoApiClient.getScopes(accessToken);
        return scopeResponse.getScopes().contains("friends");
    }
    
    public List<KakaoFriend> getLimitedKakaoFriends(String accessToken) {
        if (!canAccessKakaoFriends(accessToken)) {
            throw new KakaoScopeNotGrantedException("friends 권한이 필요합니다.");
        }
        
        KakaoFriendsResponse response = kakaoApiClient.getFriends(accessToken);
        
        // 앱에 가입한 친구만 필터링 (최대 20명)
        return response.getFriends().stream()
                .filter(friend -> friend.isAppRegistered())
                .limit(20)
                .collect(Collectors.toList());
    }
}
```

### 8.2 친구 시스템 설계

#### **친구 추가 방식**
```java
// 1. 친구 검색 (닉네임, 이메일, 전화번호)
@Service
public class FriendService {
    
    public List<UserProfile> searchFriends(String keyword) {
        return userRepository.findByNicknameContainingOrEmailContaining(keyword, keyword);
    }
}
```
```

#### **친구 초대 링크 시스템**
```java
// 친구 초대 링크 생성
@Service
public class InvitationService {
    
    public InvitationLink createInvitationLink(String userId, String meetingId) {
        String inviteCode = generateUniqueInviteCode();
        
        InvitationLink link = InvitationLink.builder()
                .inviteCode(inviteCode)
                .userId(userId)
                .meetingId(meetingId)
                .expiresAt(LocalDateTime.now().plusDays(7))
                .build();
        
        invitationLinkRepository.save(link);
        
        return link;
    }
    
    // 초대 링크로 참여
    public Meeting joinByInvitationLink(String inviteCode, String newUserId) {
        InvitationLink link = invitationLinkRepository.findByInviteCode(inviteCode)
                .orElseThrow(() -> new InvalidInvitationLinkException());
        
        if (link.getExpiresAt().isBefore(LocalDateTime.now())) {
            throw new ExpiredInvitationLinkException();
        }
        
        // 약속에 참여자 추가
        Meeting meeting = meetingService.addParticipant(link.getMeetingId(), newUserId);
        
        // 초대 링크 사용 처리
        link.setUsed(true);
        invitationLinkRepository.save(link);
        
        return meeting;
    }
}
```

### 8.3 실시간 게임 시스템 설계

#### **게임 방 관리**
```java
// 게임 방 생성 및 관리
@Service
public class GameRoomService {
    
    // 친구와 게임 방 생성
    public GameRoom createGameRoom(String hostUserId, List<String> friendUserIds, GameType gameType) {
        GameRoom room = GameRoom.builder()
                .roomId(UUID.randomUUID().toString())
                .hostUserId(hostUserId)
                .participants(new ArrayList<>(friendUserIds))
                .gameType(gameType)
                .status(GameRoomStatus.WAITING)
                .createdAt(LocalDateTime.now())
                .build();
        
        // Redis에 게임 방 정보 캐싱
        cacheGameRoom(room);
        
        // 참가자들에게 게임 초대 알림
        for (String userId : friendUserIds) {
            notificationService.sendGameInvitation(userId, room);
        }
        
        return room;
    }
    
    // 게임 방 참여
    public void joinGameRoom(String roomId, String userId) {
        GameRoom room = getGameRoom(roomId);
        
        if (room.getStatus() == GameRoomStatus.WAITING && 
            room.getParticipants().contains(userId)) {
            
            // WebSocket을 통해 실시간 게임 참여
            gameWebSocketService.joinRoom(roomId, userId);
            
            // 모든 참가자가 준비되면 게임 시작
            if (isAllParticipantsReady(roomId)) {
                startGame(roomId);
            }
        }
    }
}
```

#### **WebSocket을 통한 실시간 게임**
```java
// WebSocket 게임 서비스
@Service
public class GameWebSocketService {
    
    // 게임 방 참여
    public void joinRoom(String roomId, String userId) {
        String sessionKey = "game:" + roomId + ":" + userId;
        
        // Redis에 게임 세션 저장
        GameSession session = GameSession.builder()
                .roomId(roomId)
                .userId(userId)
                .status(GameSessionStatus.READY)
                .joinedAt(LocalDateTime.now())
                .build();
        
        redisTemplate.opsForValue().set(sessionKey, objectMapper.writeValueAsString(session), Duration.ofMinutes(30));
        
        // 방의 다른 참가자들에게 참여 알림
        broadcastToRoom(roomId, "USER_JOINED", Map.of("userId", userId));
    }
    
    // 실시간 게임 진행
    public void handleGameAction(String roomId, String userId, GameAction action) {
        GameRoom room = getGameRoom(roomId);
        
        switch (action.getType()) {
            case "QUIZ_ANSWER":
                handleQuizAnswer(roomId, userId, action.getData());
                break;
            case "GAME_READY":
                handleGameReady(roomId, userId);
                break;
            case "GAME_FINISH":
                handleGameFinish(roomId, userId, action.getData());
                break;
        }
        
        // 실시간으로 모든 참가자에게 게임 상태 업데이트
        broadcastToRoom(roomId, "GAME_UPDATE", getGameState(roomId));
    }
}
```

### 8.4 미니게임 시스템 설계

#### **게임 유형**
- **퀴즈 게임**: 약속 관련 퀴즈, 승리자가 위치 우선권 획득
-> 데이터 베이스를 대용량으로 사용하고 싶으면 특정 지역에 대한 퀴즈문제만 퀴즈로 내게끔 하고 데이터 베이스에 지역별로 관련 퀴즈 1000개씩 넣어서 우리나라 모든 지역 관련 데이터 다 넣어버리기.
- **반응 속도 게임**: 빠른 반응이 필요한 미니게임
- **기억력 게임**: 카드 매칭, 순서 기억 게임
- **협력 게임**: 함께 해결하는 퍼즐 게임

### 8.5 보상 시스템
```json
// 게임 보상 구조
{
  "gameId": "game789",
  "winnerId": "user123",
  "rewards": {
    "locationPriority": 0.7, // 중간지점에서 70% 가까운 위치 우선권
    "quizBonus": 0.1, // 퀴즈 정답당 10% 추가 우선권
    "points": 100,
    "badges": ["first_winner", "speed_demon", "quiz_master"],
    "specialFeatures": ["premium_recommendations", "priority_support"]
  }
}
```

### 8.6 게임 진행 플로우
1. **게임 시작**: 약속 생성 후 자동 또는 수동 게임 시작
2. **게임 진행**: WebSocket을 통한 실시간 게임 진행
3. **퀴즈 시스템**: 정답 개수에 따른 추가 위치 우선권 부여
4. **결과 처리**: 승리자 결정 및 보상 지급
5. **위치 조정**: 승리자에게 유리한 위치로 약속 장소 재계산
6. **최종 확정**: 조정된 위치에서 최종 약속 장소 추천

## 9. 위치 서비스 API 선택 및 비용 분석

### 9.1 Google Maps API 비용 분석

#### **무료 할당량 (매월)**
```yaml
# Google Maps API 무료 할당량
free-quota:
  places-api: 28500        # 장소 검색
  geocoding-api: 2500      # 주소 ↔ 좌표 변환
  directions-api: 2500     # 경로 계산
  distance-matrix: 2500    # 거리/시간 계산
```

#### **초과 시 요금 (2024년 기준)**
```yaml
# Google Maps API 초과 요금
pricing:
  places-api: $17 per 1000 calls
  geocoding-api: $5 per 1000 calls
  directions-api: $5 per 1000 calls
  distance-matrix: $5 per 1000 calls
```

#### **Meeting Place 프로젝트 예상 사용량 (주소 저장 전략)**
```java
// 월간 사용량 예상 (사용자 1,000명 기준, 주소 저장 전략 적용)
@Service
public class LocationApiUsageCalculator {
    
    public MonthlyUsage calculateExpectedUsage(int userCount) {
        return MonthlyUsage.builder()
                .placesApiCalls(userCount * 5)        // 장소 검색: 사용자당 5회
                .geocodingApiCalls(userCount * 0.1)   // 주소 변환: 사용자당 0.1회 (새 주소 등록 시에만)
                .directionsApiCalls(userCount * 2)    // 경로 계산: 사용자당 2회 (중간지점까지 경로)
                .distanceMatrixCalls(userCount * 0)   // 거리 계산: 백엔드 로직으로 처리
                .build();
    }
    
    public CostEstimate estimateMonthlyCost(MonthlyUsage usage) {
        double totalCost = 0.0;
        
        // Places API 비용
        if (usage.getPlacesApiCalls() > 28500) {
            int excess = usage.getPlacesApiCalls() - 28500;
            totalCost += (excess / 1000.0) * 17;
        }
        
        // Geocoding API 비용 ($5 per 1,000 calls)
        if (usage.getGeocodingApiCalls() > 2500) {
            int excess = usage.getGeocodingApiCalls() - 2500;
            totalCost += (excess / 1000.0) * 5;
        }
        
        // Directions API 비용 (중간지점 계산은 백엔드 로직으로 처리)
        // if (usage.getDirectionsApiCalls() > 2500) {
        //     int excess = usage.getDirectionsApiCalls() - 2500;
        //     totalCost += (excess / 1000.0) * 5;
        // }
        
        // Distance Matrix API 비용 (거리 계산은 백엔드 로직으로 처리)
        // if (usage.getDistanceMatrixCalls() > 2500) {
        //     int excess = usage.getDistanceMatrixCalls() - 2500;
        //     totalCost += (excess / 1000.0) * 5;
        // }
        
        return CostEstimate.builder()
                .monthlyCost(totalCost)
                .isWithinFreeQuota(totalCost == 0.0)
                .build();
    }
}
```

### 9.2 대안 위치 서비스 API

#### **1. Naver Maps API (국내 서비스)**
```yaml
# Naver Maps API
naver-maps:
  pricing: 무료 (일일 25,000회 제한)
  features:
    - 지오코딩/리버스 지오코딩
    - 경로 검색
    - 장소 검색
    - 거리 계산
  pros:
    - 무료
    - 한국 지도 데이터 정확도 높음
    - 한국어 지원 우수
  cons:
    - 해외 서비스 불가
    - API 문서가 Google보다 부족
```

#### **2. Kakao Maps API (국내 서비스) - 추천**
```yaml
# Kakao Maps API
kakao-maps:
  pricing: 무료 (일일 300,000회 제한)
  features:
    - 지오코딩/리버스 지오코딩
    - 경로 검색 (대중교통, 자동차, 도보, 자전거)
    - 장소 검색
    - 키워드 검색
    - 실시간 교통 정보
  pros:
    - 무료
    - 한국 지도 데이터 정확도 높음
    - 카카오 계정 연동 가능
    - 대중교통 경로 검색 정확도 우수
    - 실시간 교통 상황 반영
  cons:
    - 해외 서비스 불가
    - API 제한이 있음
```

#### **3. T Map API (SKT 교통 정보)**
```yaml
# T Map API
tmap:
  pricing: 무료 (월 10,000회 제한)
  features:
    - 지오코딩/리버스 지오코딩
    - 경로 검색 (대중교통, 자동차)
    - 장소 검색
    - 실시간 교통 정보
  pros:
    - 무료
    - SKT 교통 정보 활용
    - 실시간 교통 상황 반영
    - 한국 교통 정보 정확
  cons:
    - API 사용량 제한
    - 개발자 등록 필요
    - 해외 서비스 불가
```

#### **4. OpenStreetMap + Nominatim (무료)**
```yaml
# OpenStreetMap + Nominatim
openstreetmap:
  pricing: 완전 무료
  features:
    - 지오코딩/리버스 지오코딩
    - 경로 검색 (OSRM 사용)
    - 장소 검색
  pros:
    - 완전 무료
    - 전 세계 데이터
    - 오픈소스
  cons:
    - 정확도가 상용 서비스보다 낮을 수 있음
    - 속도가 느릴 수 있음
    - 사용량 제한 있음
```

### 9.3 하이브리드 전략

#### **주소 기반 좌표 저장 전략**
```java
@Service
public class AddressCoordinateService {
    
    // 사용자 주소 등록 시 좌표 변환 및 저장
    public UserLocation registerUserAddress(String userId, String fullAddress) {
        // 기존 주소 검색 후 재사용 또는 새로 Geocoding API 호출
        UserLocation existingLocation = userLocationRepository.findByFullAddress(fullAddress);
        
        if (existingLocation != null) {
            return createUserLocation(userId, fullAddress, existingLocation);
        }
        
        // Google Geocoding API 호출
        LocationInfo locationInfo = googleGeocodingService.geocodeAddress(fullAddress);
        String dongLevelAddress = extractDongLevelAddress(locationInfo.getFormattedAddress());
        
        return createUserLocation(userId, fullAddress, locationInfo, dongLevelAddress);
    }
    
    // 저장된 좌표로 중간지점 계산 (API 호출 없음)
    public MidpointResult calculateMidpointFromStoredCoordinates(String user1Id, String user2Id) {
        UserLocation user1 = userLocationRepository.findByUserId(user1Id);
        UserLocation user2 = userLocationRepository.findByUserId(user2Id);
        
        Location midpoint = locationCalculationService.calculateMidpoint(user1, user2);
        String dongAddress = findNearestDongAddress(midpoint);
        
        return MidpointResult.builder()
                .midpoint(midpoint)
                .dongLevelAddress(dongAddress)
                .build();
    }
}
```
```
    
    // 2. API 우선순위 설정
    public LocationInfo getLocationWithFallback(String address) {
        try {
            // 1순위: Google Maps API (정확도 높음)
            return googleMapsApi.getLocation(address);
        } catch (Exception e) {
            try {
                // 2순위: Naver Maps API (무료)
                return naverMapsApi.getLocation(address);
            } catch (Exception e2) {
                // 3순위: OpenStreetMap (완전 무료)
                return openStreetMapApi.getLocation(address);
            }
        }
    }
    
    // 3. 배치 처리를 통한 비용 절약
    public List<LocationInfo> batchGeocode(List<String> addresses) {
        // 여러 주소를 한 번에 처리하여 API 호출 횟수 줄이기
        return geocodingApi.batchGeocode(addresses);
    }
}
```

#### **백엔드 위치 계산 로직**
```java
@Service
public class LocationCalculationService {
    
    // 두 지점 간 중간지점 계산 (3D 구면 좌표계)
    public Location calculateMidpoint(Location point1, Location point2) {
        // 3D 구면 좌표계로 변환하여 정확한 중간지점 계산
        double lat1 = Math.toRadians(point1.getLatitude());
        double lon1 = Math.toRadians(point1.getLongitude());
        double lat2 = Math.toRadians(point2.getLatitude());
        double lon2 = Math.toRadians(point2.getLongitude());
        
        // 3D 좌표 변환 및 중간지점 계산
        double x1 = Math.cos(lat1) * Math.cos(lon1);
        double y1 = Math.cos(lat1) * Math.sin(lon1);
        double z1 = Math.sin(lat1);
        
        double x2 = Math.cos(lat2) * Math.cos(lon2);
        double y2 = Math.cos(lat2) * Math.sin(lon2);
        double z2 = Math.sin(lat2);
        
        double midX = (x1 + x2) / 2.0;
        double midY = (y1 + y2) / 2.0;
        double midZ = (z1 + z2) / 2.0;
        
        double midLat = Math.atan2(midZ, Math.sqrt(midX * midX + midY * midY));
        double midLon = Math.atan2(midY, midX);
        
        return Location.builder()
                .latitude(Math.toDegrees(midLat))
                .longitude(Math.toDegrees(midLon))
                .build();
    }
    
    // 두 지점 간 거리 계산 (Haversine 공식)
    public double calculateDistance(Location point1, Location point2) {
        final double R = 6371; // 지구 반지름 (km)
        
        double latDistance = Math.toRadians(point2.getLatitude() - point1.getLatitude());
        double lonDistance = Math.toRadians(point2.getLongitude() - point1.getLongitude());
        
        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(point1.getLatitude())) * Math.cos(Math.toRadians(point2.getLatitude()))
                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return R * c; // km 단위
    }
    
    // 게임 승리자에 따른 가중 중간지점 계산
    public Location calculateWeightedMidpoint(Location point1, Location point2, 
                                            String winner, double winnerWeight) {
        if (winner.equals("user1")) {
            return calculateWeightedPoint(point1, point2, winnerWeight);
        } else {
            return calculateWeightedPoint(point2, point1, winnerWeight);
        }
    }
}
```
```

#### **위치 입력 및 중간지점 계산 플로우**
```java
@Service
public class LocationInputService {
    
    // 사용자가 지도에서 위치 선택
    public LocationInputResponse handleLocationSelection(LocationSelectionRequest request) {
        Location userLocation = Location.builder()
                .latitude(request.getLatitude())
                .longitude(request.getLongitude())
                .build();
        
        String address = googleGeocodingService.reverseGeocode(
                userLocation.getLatitude(), userLocation.getLongitude());
        
        return LocationInputResponse.builder()
                .location(userLocation)
                .address(address)
                .build();
    }
    
    // 두 사용자의 중간지점 계산
    public MidpointCalculationResponse calculateMidpoint(Location user1Location, Location user2Location) {
        Location midpoint = locationCalculationService.calculateMidpoint(user1Location, user2Location);
        String midpointAddress = googleGeocodingService.reverseGeocode(
                midpoint.getLatitude(), midpoint.getLongitude());
        
        return MidpointCalculationResponse.builder()
                .midpoint(midpoint)
                .address(midpointAddress)
                .build();
    }
}
```

#### **주소 저장 기반 최적화 전략**
```yaml
# Meeting Place 프로젝트 주소 저장 기반 전략
strategy:
  user-registration:
    - 정확한 주소 입력 (도로명 주소)
    - 주소 등록 시 1회만 Geocoding API 호출
    - 좌표값을 DB에 영구 저장
    - 동 단위 주소 추출하여 저장
  
  daily-usage:
    - 저장된 좌표로 중간지점 계산 (API 호출 없음)
    - 백엔드 로직으로 거리 계산 (API 호출 없음)
    - Kakao Maps API로 경로 계산 (실시간 필요)
    - Places API로 장소 검색
  
  api-usage:
    - Geocoding API: 사용자당 월 0.1회
    - Directions API: 사용자당 월 2회
    - Places API: 사용자당 월 5회
  
  cost-benefit:
    - Geocoding 비용: 90% 절약
    - 총 비용: 사용자 1,000명 기준 월 $0-10
```

## 10. 성능 최적화 전략

### 10.1 Redis 캐싱 전략

#### **Redis는 별도의 캐시 서버입니다!**
```java
// 애플리케이션에서 Redis 서버와 통신하여 캐싱 사용
@Service
public class RecommendationCache {
    
    // RedisTemplate: Spring Boot에서 Redis 서버와 통신하는 클라이언트
    private final RedisTemplate<String, String> redisTemplate;
    
    // Redis 서버에 캐시 저장
    public void cacheRecommendation(String cacheKey, RecommendationResponse result) {
        String jsonData = objectMapper.writeValueAsString(result);
        redisTemplate.opsForValue().set(cacheKey, jsonData, Duration.ofHours(1));
    }
    
    // Redis 서버에서 캐시 조회
    public Optional<RecommendationResponse> getCachedRecommendations(String cacheKey) {
        String cachedData = redisTemplate.opsForValue().get(cacheKey);
        if (cachedData != null) {
            return Optional.of(objectMapper.readValue(cachedData, RecommendationResponse.class));
        }
        return Optional.empty();
    }
}
```

#### **Redis 서버 활용 시나리오**
```java
// 1. 장소 추천 결과 캐싱 (1시간 TTL)
public void cacheRecommendation(String cacheKey, RecommendationResponse result) {
    redisTemplate.opsForValue().set("recommendation:" + cacheKey, 
            objectMapper.writeValueAsString(result), Duration.ofHours(1));
}

// 2. 사용자 세션 관리 (24시간 TTL)
public void cacheUserSession(String userId, UserSession session) {
    redisTemplate.opsForValue().set("session:" + userId, 
            objectMapper.writeValueAsString(session), Duration.ofHours(24));
}

// 3. 게임 상태 캐싱 (30분) - 실시간 게임 진행 중 빠른 접근용
public void cacheGameState(String gameId, GameState state) {
    redisTemplate.opsForValue().set("game:" + gameId, 
            objectMapper.writeValueAsString(state), Duration.ofMinutes(30));
}

// 4. 약속 초대 정보 캐싱 (7일 TTL)
public void cacheMeetingInvitation(String invitationId, MeetingInvitation invitation) {
    redisTemplate.opsForValue().set("meeting:invitation:" + invitationId, 
            objectMapper.writeValueAsString(invitation), Duration.ofDays(7));
}

// 5. API 요청 제한 (Rate Limiting)
public boolean checkRateLimit(String userId, String endpoint) {
    String key = "rate:limit:" + userId + ":" + endpoint;
    Long count = redisTemplate.opsForValue().increment(key);
    if (count == 1) {
        redisTemplate.expire(key, Duration.ofMinutes(1));
    }
    return count <= 100; // 1분에 100회 제한
}
```

#### **Redis 서버 vs 애플리케이션 메모리 캐싱 비교**

| 구분 | Redis 서버 | 애플리케이션 메모리 |
|------|------------|-------------------|
| **속도** | 빠름 (네트워크 지연 있음) | 매우 빠름 |
| **공유** | ✅ 여러 서비스 간 공유 | ❌ 서비스별 독립 |
| **영속성** | ✅ 서버 재시작해도 유지 | ❌ 재시작 시 손실 |
| **관리** | ✅ TTL 자동 관리 | ❌ 수동 관리 필요 |
| **확장성** | ✅ 수평 확장 가능 | ❌ 확장 시 동기화 문제 |

#### **Redis 서버의 장점**
```java
// ✅ Redis 서버 사용의 장점

// 1. 메모리 기반 빠른 접근
// - 디스크 I/O 없이 메모리에서 직접 조회
// - 평균 0.1ms 이하의 응답 시간

// 2. 여러 애플리케이션 간 공유
// - User Service, Place Service, Game Service 모두 같은 Redis 사용 가능
// - 서비스 간 데이터 공유 용이

// 3. 자동 만료 (TTL)
// - 설정된 시간 후 자동으로 데이터 삭제
// - 메모리 관리 자동화

// 4. 다양한 데이터 구조 지원
// - String, List, Set, Hash, Sorted Set 등
// - 복잡한 캐싱 로직 구현 가능
```

#### **캐싱 플로우**
```java
// 1. 애플리케이션에서 캐시 조회 요청
String cacheKey = "rec:perplexity:abc123";
String cachedData = redisTemplate.opsForValue().get(cacheKey);

// 2. Redis 서버에서 응답
// - 캐시 히트: 데이터 반환
// - 캐시 미스: null 반환

// 3. 캐시 미스 시 원본 데이터 조회
if (cachedData == null) {
    // DB 조회 또는 API 호출
    RecommendationResponse result = getRecommendationsFromAPI();
    
    // 4. Redis 서버에 캐시 저장
    redisTemplate.opsForValue().set(cacheKey, objectMapper.writeValueAsString(result), Duration.ofHours(1));
}
```

#### **Redis 서버 설정**
```yaml
# application.yml에서 Redis 서버 정보 설정
spring:
  redis:
    host: localhost        # Redis 서버 주소
    port: 6379            # Redis 서버 포트
    timeout: 2000ms       # 연결 타임아웃
    database: 0           # Redis 데이터베이스 번호
```

#### **기타 캐싱 전략**
- **CDN**: 정적 리소스 (이미지, CSS, JS)
- **데이터베이스 캐시**: 쿼리 결과 캐싱

### 10.2 데이터베이스 최적화
- **읽기 복제본**: 조회 전용 데이터베이스 분리
- **인덱스 최적화**: 위치 기반 쿼리를 위한 공간 인덱스
- **파티셔닝**: 시간 기반 데이터 파티셔닝

### 10.3 비동기 처리
- **메시지 큐**: 이벤트 처리, 알림 발송
- **배치 처리**: 대량 데이터 처리, 통계 계산
- **백그라운드 작업**: 데이터 정리, 리포트 생성

## 10. 모니터링 및 관찰성

### 10.1 메트릭 수집
- **비즈니스 메트릭**: 약속 생성 수, 게임 참여율, 사용자 만족도
- **기술 메트릭**: 응답 시간, 오류율, 처리량
- **시스템 메트릭**: CPU, 메모리, 네트워크 사용량

### 10.2 로깅 전략
- **구조화된 로깅**: JSON 형태의 로그 출력
- **분산 추적**: 요청 흐름 추적 (Jaeger, Zipkin)
- **중앙화된 로깅**: ELK Stack을 통한 로그 수집 및 분석

### 10.4 알림 시스템
- **실시간 알림**: 시스템 장애, 성능 저하 알림
- **비즈니스 알림**: 사용자 활동, 게임 결과 알림
- **예측 알림**: 시스템 부하 예측 기반 사전 알림


      - kafka

  # ... 기타 서비스들

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: meetingplace
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  kafka:
    image: confluentinc/cp-kafka:7.3.0
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
    depends_on:
      - zookeeper

  zookeeper:
    image: confluentinc/cp-zookeeper:7.3.0
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

volumes:
  postgres_data:
```

### 10.3 CI/CD 파이프라인 (GitHub Actions + ArgoCD)

#### GitHub Actions CI Pipeline
```yaml
# .github/workflows/ci-pipeline.yml
name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [user-service, location-service, place-service, game-service, meeting-service, notification-service]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
    
    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
    
    - name: Run tests
      run: |
        cd backend/${{ matrix.service }}
        mvn test
    
    - name: Build Docker image
      run: |
        cd backend/${{ matrix.service }}
        docker build -t meeting-place/${{ matrix.service }}:${{ github.sha }} .
    
    - name: Push to Container Registry
      run: |
        echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin
        docker push meeting-place/${{ matrix.service }}:${{ github.sha }}

  security-scan:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'meeting-place/user-service:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
```

#### ArgoCD CD Pipeline
```yaml
# argocd/applications/meeting-place-app.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: meeting-place
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/your-org/meeting-place
    targetRevision: main
    path: k8s
  destination:
    server: https://kubernetes.default.svc
    namespace: meeting-place
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
    - CreateNamespace=true
    - PrunePropagationPolicy=foreground
    - PruneLast=true
```

#### Kubernetes 배포 설정
```yaml
# k8s/deployments/user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
  namespace: meeting-place
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: meeting-place/user-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
```

### 10.4 배포 환경 전략

#### 환경별 배포 전략
- **Development**: GitHub Actions → Docker Hub → ArgoCD → Dev Cluster
- **Staging**: GitHub Actions → Docker Hub → ArgoCD → Staging Cluster
- **Production**: GitHub Actions → Docker Hub → ArgoCD → Production Cluster

#### 롤백 전략
- **ArgoCD 롤백**: 이전 버전으로 자동 롤백
- **Blue-Green 배포**: 무중단 배포 및 롤백
- **Canary 배포**: 점진적 배포로 위험 최소화

## 11. 모니터링 및 관찰성

### 11.1 메트릭 수집
- **비즈니스 메트릭**: 약속 생성 수, 게임 참여율, 사용자 만족도
- **기술 메트릭**: 응답 시간, 오류율, 처리량
- **시스템 메트릭**: CPU, 메모리, 네트워크 사용량

### 11.2 로깅 전략
- **구조화된 로깅**: JSON 형태의 로그 출력
- **분산 추적**: 요청 흐름 추적 (Jaeger, Zipkin)
- **중앙화된 로깅**: ELK Stack을 통한 로그 수집 및 분석

## 12. 보안 및 개인정보 보호

### 12.1 위치 정보 보호
- **데이터 암호화**: 위치 정보 암호화 저장
- **접근 제어**: 사용자별 위치 정보 접근 권한 관리
- **데이터 수명**: 위치 정보 자동 삭제 정책

### 12.2 API 보안
- **JWT 인증**: 토큰 기반 인증
- **Rate Limiting**: API 호출 제한
- **입력 검증**: 모든 입력 데이터 검증

### 12.3 개인정보 처리
- **GDPR 준수**: 개인정보 처리 동의 및 삭제 권리
- **데이터 최소화**: 필요한 최소한의 데이터만 수집
- **투명성**: 데이터 사용 목적 명시 